[[azure-local-running-app]]
= Running the Application Locally

'''

In this chapter we will push the containers we've built to Azure Container Registry so we can still run them locally, and later on Azure Container Apps.

[NOTE]
====
Building containers locally and pushing them to Azure Container Registry can take from 15 to 30 minutes (depending on your CPU and bandwith).
====

In this section, we are going to package our microservices into containers.
In particular, we are going to produce Linux 64 bits native executables and runs them in a container.
The native compilation uses the OS and architecture of the host system.

And... Linux Containers are ... _Linux_.
So to build a container with a Linux native executable (even if you are on Windows or Mac), Quarkus comes with a trick to produce these executable.

It's a pretty straightforward `Dockerfile` taking a minimal base image and copying the generated native executable.

[TIP]
====
Building a native executable takes time, CPU, and memory.
It's even more accurate in the container.
So, first, be sure that your container system has enough memory to build the executable.
It requires at least 6Gb of memory, 8Gb is recommended.
====

[example, role="cta"]
--
Execute the following commands to build all our microservices and the UI.
This will build Docker images out of Linux native executables:
Under the `quarkus-workshop-super-heroes/super-heroes` directory execute the following Docker commands:

[source,shell,indent=0]
----
include::{projectdir}/infrastructure/azure-build-push-registry.sh[tags=adocCompiling]
----
[source,shell,indent=0]
----
include::{projectdir}/infrastructure/azure-build-push-registry.sh[tags=adocBuilding]
----
--

== Pushing containers to Azure Container Registry

Now that we have all our Docker containers running locally, let's push them to Azure Container Registry.

[NOTE]
====
Make sure you've set all the environment variables defined in the previous chapter and that you've also created the resource group and the Azure Container Registry.
====

[example, role="cta"]
--
Before you can push an image to your registry, you must tag it with the fully qualified name of your registry login server (the `REGISTRY_URL` variable).
Tag the image using the `docker tag` commands:

[source,shell,indent=0]
----
include::{projectdir}/infrastructure/azure-build-push-registry.sh[tags=adocTagging]
----
--

[example, role="cta"]
--
To be able to push these Docker images to Azure Registry, we first need to log in to the registry:

[source,shell,indent=0]
----
include::{projectdir}/infrastructure/azure-build-push-registry.sh[tags=adocLogging]
----

You should see the prompt _Login Succeeded_.

Then, push all the images with the following commands:

[source,shell,indent=0]
----
include::{projectdir}/infrastructure/azure-build-push-registry.sh[tags=adocPushing]
----

You can check that the images have been pushed to Azure Container Registry by executing the following command:

[source,shell,indent=0]
----
include::{projectdir}/infrastructure/azure-build-push-registry.sh[tags=adocListing]
----

You can also get some information on a particular repository or image if needed:

[source,shell,indent=0]
----
include::{projectdir}/infrastructure/azure-build-push-registry.sh[tags=adocShowing]
----

You can visualize the content of the registry on the https://portal.azure.com[Azure Portal].

image::azure-portal-4.png[]
--

== Running remote containers

[NOTE]
====
[example, role="cta"]
--

If you haven't skipped the previous optional sections and built the containers your self, you should edit the `docker-compose-app-remote.yaml` file under `super-heroes/infrastructure` and change the name `superheroesregistry` with the value of the `$REGISTRY` variable.
--
====

[example, role="cta"]
--
Now that we have all our Docker containers pushed to Azure Container Registry, let's execute them with:

[source,shell]
----
docker compose -f docker-compose-app-remote.yaml up
----
--
s
Once all the containers are started, you can:

* Go to http://localhost:8080 to check the main UI
* Go to http://localhost:8085 to check the statistics UI
* curl http://localhost:8084/api/villains | jq
* curl http://localhost:8083/api/heroes | jq
* curl http://localhost:8082/api/fights/randomfighters | jq

On http://localhost:8080 you should see the user interface, and you should be able to fight super heroes against super villains:

ifdef::use-ai[]
image::angular-ui-ai.png[]
endif::use-ai[]
ifndef::use-ai[]
image::angular-ui.png[]
endif::use-ai[]


On http://localhost:8085 you should see the statistics of the fights.
When super heroes and super heroes are fights, the statistics shows which one has won the most fights, and the percentage of fights won by the two groups.
The UI is automatically updated at each fight:

image::angular-ui-stats.png[]

You should see the user interface and everything should work.
Remember to shutdown the entire application with:

[source,shell]
----
docker compose -f docker-compose-app-remote.yaml down
----

Ok, enough running these containers locally!
In the next chapter we will take these remote containers, configure them, and make them work remotely on Azure Container Apps.
