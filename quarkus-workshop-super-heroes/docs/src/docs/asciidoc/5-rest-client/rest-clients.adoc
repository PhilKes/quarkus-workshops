[[fault-tolerance-rest-client]]
= REST Client

This chapter explains how to use the MicroProfile REST Client in order to interact with REST APIs with very little effort.footnote:[MicroProfile REST Client https://github.com/eclipse/microprofile-rest-client]

== Directory Structure

Remember the structure of the Fight microservice:

[plantuml]
----
@startsalt
{
{
T
.
+ src
++ main
+++ docker
+++ java
++++ io
+++++ quarkus
++++++ workshop
+++++++ superheroes
++++++++ fight
+++++++++ Fight.java
+++++++++ FightResource.java
+++++++++ FightService.java
+++++++++ Fighters.java
+++++++++ client
+++++++++++ Hero.java
+++++++++++ HeroProxy.java
+++++++++++ Villain.java
+++++++++++ VillainProxy.java
+++ resources
++++ META-INF
+++++ resources
++++++ index.html
+++++ application.properties
+++++ import.sql
++ test
+++ java
++++ io
+++++ quarkus
++++++ workshop
++++++++ superheroes
+++++++++ fight
++++++++++ FightResourceTest.java
+++++++++ client
+++++++++++ DefaultTestHero.java
+++++++++++ DefaultTestVillain.java
+++++++++++ MockHeroProxy.java
+++++++++++ MockVillainProxy.java
+ pom.xml
}
}
@endsalt
----

We are going to rework the:

* `FightService` class
* `FightResourceTest` class
* `application.properties`

== Installing the Reactive REST Client Dependency

icon:hand-point-right[role="red",size=2x] [red big]#Call to action#

To install the Reactive REST Client dependency, just run the following command in the Fight microservice:

[source,shell]
----
./mvnw quarkus:add-extension -Dextensions="io.quarkus:quarkus-rest-client-reactive-jackson"
----

This will add the following dependency in the `pom.xml` file:

[source,xml,indent=0]
----
<dependency>
  <groupId>io.quarkus</groupId>
  <artifactId>quarkus-rest-client-reactive-jackson</artifactId>
</dependency>
----

This dependency imports both the reactive rest client implementation and the JSON mapping support (which uses Jackson).

== FightService Invoking External Microservices

Remember that in the previous sections we left the `FightService.findRandomFighters()` method returns `null`.
We have to fix this.
What we actually want is to invoke both the Hero and Villain APIs, asking for a random hero and a random villain.

icon:hand-point-right[role="red",size=2x] [red big]#Call to action#

For that, replace the `findRandomFighters` method with the following code to the `FightService` class:

[source,java,indent=0]
----
@RestClient HeroProxy heroProxy;
@RestClient VillainProxy villainProxy;

// ...

Fighters findRandomFighters() {
    Hero hero = findRandomHero();
    Villain villain = findRandomVillain();
    Fighters fighters = new Fighters();
    fighters.hero = hero;
    fighters.villain = villain;
    return fighters;
}

Villain findRandomVillain() {
    return villainProxy.findRandomVillain();
}

Hero findRandomHero() {
   return heroProxy.findRandomHero();
}


----

Note the Rest client injection.
They use the `@RestClient` qualifier, i.e. a bean selector.
With Quarkus, when you use a qualifier, you can omit `@Inject`.

[NOTE]
--
If not done automatically by your IDE, add the following import statement: `import org.eclipse.microprofile.rest.client.inject.RestClient;`
--

== Creating the Interfaces

Using the MicroProfile REST Client is as simple as creating an interface using the proper JAX-RS and MicroProfile annotations.

icon:hand-point-right[role="red",size=2x] [red big]#Call to action#

In our case both interfaces should be created under the `client` subpackage and have the following content:

[source,java]
----
package io.quarkus.workshop.superheroes.fight.client;

import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

@Path("/api/heroes")
@Produces(MediaType.APPLICATION_JSON)
@RegisterRestClient
public interface HeroProxy {

    @GET
    @Path("/random")
    Hero findRandomHero();
}
----

The `findRandomHero` method gives our code the ability to query a random hero from the Hero REST API.
The client will handle all the networking and marshalling leaving our code clean of such technical details.

The purpose of the annotations in the code above is the following:

* `@RegisterRestClient` allows Quarkus to know that this interface is meant to be available for CDI injection as a REST Client
* `@Path` and `@GET` are the standard JAX-RS annotations used to define how to access the service
* `@Produces` defines the expected content-type

The `VillainProxy` is very similar and looks like this:

[source,java]
----
package io.quarkus.workshop.superheroes.fight.client;

import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

@Path("/api/villains")
@Produces(MediaType.APPLICATION_JSON)
@RegisterRestClient
public interface VillainProxy {

    @GET
    @Path("/random")
    Villain findRandomVillain();
}
----

icon:hand-point-right[role="red",size=2x] [red big]#Call to action#

Once created, go back to the `FightService` class and add the following import statements:

[source]
--
import io.quarkus.workshop.superheroes.fight.client.HeroProxy;
import io.quarkus.workshop.superheroes.fight.client.VillainProxy;
--

== Configuring REST Client Invocation

icon:hand-point-right[role="red",size=2x] [red big]#Call to action#

In order to determine the base URL to which REST calls will be made, the REST Client uses configuration from `application.properties`.
The name of the property needs to follow a certain convention which is best displayed in the following code:

[source,properties]
----
io.quarkus.workshop.superheroes.fight.client.HeroProxy/mp-rest/url=http://localhost:8083
io.quarkus.workshop.superheroes.fight.client.HeroProxy/mp-rest/scope=jakarta.inject.Singleton
io.quarkus.workshop.superheroes.fight.client.VillainProxy/mp-rest/url=http://localhost:8084
io.quarkus.workshop.superheroes.fight.client.VillainProxy/mp-rest/scope=jakarta.inject.Singleton
----

Having this configuration means that all requests performed using `HeroProxy` will use http://localhost:8083 as the base URL.
Using this configuration, calling the `findRandomHero` method of `HeroProxy` would result in an HTTP GET request being made to http://localhost:8083/api/heroes/random.

Having this configuration means that the default scope of `HeroProxy` will be `@Singleton`.
Supported scope values are `@Singleton`, `@Dependent`, `@ApplicationScoped` and `@RequestScoped`.
The default scope is `@Dependent`.
The default scope can also be defined on the interface.

Now, go back in the UI and refresh, you should see some pictures!

== Updating the Test with Mock Support

But, now we have another problem.
To run the tests of the Fight API we need the Hero and Villain REST APIs to be up and running.
To avoid this, we need to Mock the `HeroProxy` and `VillainProxy` interfaces.

Quarkus supports the use of mock objects using the CDI `@Alternative` mechanism.footnote:[Alternatives https://docs.jboss.org/weld/reference/latest/en-US/html/specialization.html#_using_alternative_stereotypes]

icon:hand-point-right[role="red",size=2x] [red big]#Call to action#

To use this simply override the bean you wish to mock with a class in the `src/test/java` directory, and put the `@Alternative` and `@Priority(1)` annotations on the bean.
Alternatively, a convenient `io.quarkus.test.Mock` stereotype annotation could be used.
This built-in stereotype declares `@Alternative`, `@Priority(1)` and `@Dependent`.

=== Mocking a Villain service

So, to mock the `VillainProxy` interface we just need to implement the following `MockVillainProxy` class (under the `client` subpackage):


[source,java]
----
include::../../../../../super-heroes/rest-fights/src/test/java/io/quarkus/workshop/superheroes/fight/client/MockVillainProxy.java[]
----

We are using some common classes for the test data.
They don't exist yet, so the IDE will complain!
Let your IDE's quick fix create the classes for you, or create them
manually, and then fill in the following contents:


[source,java]
----
include::../../../../../super-heroes/rest-fights/src/test/java/io/quarkus/workshop/superheroes/fight/client/DefaultTestVillain.java[]
----

=== Mocking a Hero service

We could create a `@Mock` for the `HeroProxy`, as we did for the Villain, but there are some drawbacks to using `@Mock`:

- Any class defined by `@Mock`
is global in scope, and can't be isolated to individual tests. That can result in unwanted cross-talk between tests.
- Because of how the mock is defined,
it's also harder to use https://site.mockito.org/[Mockito] to generate the mock instance.

Let's try a different approach.

We'll still want a class which holds test data for the hero. Create the following:

[source,java]
----
include::../../../../../super-heroes/rest-fights/src/test/java/io/quarkus/workshop/superheroes/fight/client/DefaultTestHero.java[]
----


Add the extended Quarkus Mockito support to the `fight` service's `pom.xml`:

[source,xml]
----
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-junit5-mockito</artifactId>
            <scope>test</scope>
        </dependency>
----

Now we can add the following to the top of the `FightResourceTest`:

[source,java]
----
    @InjectMock(convertScopes = true)
    @RestClient
    HeroProxy heroProxy;

    @BeforeEach
    public void setup() {
        when(heroProxy.findRandomHero()).thenReturn(DefaultTestHero.INSTANCE);
    }
----

The `when` call is a static import of `Mockito.when`. The
https://quarkus.io/guides/getting-started-testing#further-simplification-with-injectmock[`@InjectMock`] annotation results in a mock being created and made available in test methods of the test class.
Importantly, other test classes are not affected by this.

icon:hand-point-right[role="red",size=2x] [red big]#Call to action#

Finally, edit the `FightResourceTest` and add the following method:

[source,java]
--
include::../../../../../super-heroes/rest-fights/src/test/java/io/quarkus/workshop/superheroes/fight/FightResourceTest.java[tag=shouldGetRandomFighters]
--

Now, run the test from the dev mode, or from your IDE.
You can shutdown the hero and villain services to verify that the tests still pass.

Don't forget to restart them before going further.
